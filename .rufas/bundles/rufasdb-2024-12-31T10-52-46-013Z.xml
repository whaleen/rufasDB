<?xml version="1.0" encoding="UTF-8"?>
<rufas>
<bundle_head>
  <title>rufasDB</title>
  <description>all the files we have so far</description>
  <created_at>2024-12-31T10:52:46.002Z</created_at>
  <bundle_id>b_1735638431334</bundle_id>
</bundle_head>

<documents>
<document>
<source>bin/rufas</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T09:58:42.472Z</last_modified>
  <file_type>bin/rufas</file_type>
</document_metadata>
<content>#!/usr/bin/env node
require('../dist/cli/index.js')
</content>
</document>
<document>
<source>src/cli/index.ts</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T09:49:10.919Z</last_modified>
  <file_type>ts</file_type>
</document_metadata>
<content>#!/usr/bin/env node
// src/cli/index.ts
import fs from 'fs/promises'
import path from 'path'

async function generateTypes() {
  try {
    const schemaPath = path.join(process.cwd(), 'schema.rufas')
    const schemaContent = await fs.readFile(schemaPath, 'utf-8')

    const types = schemaContent
      .split('model')
      .filter(Boolean)
      .map((model) => {
        const [name, ...fields] = model.trim().split('\n')
        return `${name.trim()} {\n  ${fields.join('\n  ')}\n}`
      })
      .join('\n\n')

    const output = `// Generated by RufasDB
export type Schema = {
${types}
}
`

    await fs.writeFile('rufas.d.ts', output)
    console.log('âœ¨ Generated types file')
  } catch (error) {
    console.error('Failed to generate types:', error)
    process.exit(1)
  }
}

const command = process.argv[2]
if (command === 'generate') {
  generateTypes()
} else {
  console.log('Unknown command. Available commands: generate')
}
</content>
</document>
<document>
<source>src/client.ts</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T10:04:16.861Z</last_modified>
  <file_type>ts</file_type>
</document_metadata>
<content>// src/client.ts
import { RufasEngine } from './engine'
import type { QueryOptions } from './types'

export class RufasClient<Schema extends Record<string, any>> {
  private engine: RufasEngine<Schema>

  constructor(dirHandle: FileSystemDirectoryHandle, schema: Schema) {
    this.engine = new RufasEngine<Schema>(dirHandle, schema)
  }

  model<T extends keyof Schema>(name: T) {
    return {
      findMany: (options?: QueryOptions<Schema[T]>) =>
        this.engine.findMany(name, options),

      create: (data: Omit<Schema[T], 'id'>) => this.engine.create(name, data),

      update: (id: string, data: Partial<Schema[T]>) =>
        this.engine.update(name, id, data),

      delete: (id: string) => this.engine.delete(name, id),
    }
  }
}
</content>
</document>
<document>
<source>src/engine.ts</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T10:04:09.075Z</last_modified>
  <file_type>ts</file_type>
</document_metadata>
<content>// src/engine.ts
import type { WhereCondition, QueryOptions } from './types'

export class RufasEngine<Schema extends Record<string, any>> {
  private data: { [K in keyof Schema]: any[] } = {} as any
  private isLocked = false
  private lockTimeout = 5000
  private operationQueue: Array<() => Promise<void>> = []
  private isProcessing = false

  constructor(private dirHandle: FileSystemDirectoryHandle, schema: Schema) {
    this.initializeSchema(schema)
  }

  private initializeSchema(schema: Schema) {
    Object.keys(schema).forEach((model) => {
      this.data[model as keyof Schema] = []
    })
  }

  private async acquireLock(): Promise<void> {
    if (this.isLocked) throw new Error('Storage is locked')
    this.isLocked = true
    setTimeout(() => (this.isLocked = false), this.lockTimeout)
  }

  private releaseLock(): void {
    this.isLocked = false
  }

  private async queueOperation<T>(operation: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.operationQueue.push(async () => {
        try {
          const result = await operation()
          resolve(result)
        } catch (error) {
          reject(error)
        }
      })
      this.processQueue()
    })
  }

  private async processQueue() {
    if (this.isProcessing || this.isLocked) return
    this.isProcessing = true

    while (this.operationQueue.length > 0) {
      await this.acquireLock()
      try {
        const operation = this.operationQueue.shift()!
        await operation()
      } finally {
        this.releaseLock()
      }
    }

    this.isProcessing = false
  }

  private async read(model: string): Promise<any[]> {
    const dbHandle = await this.dirHandle.getDirectoryHandle('.rufasdb', {
      create: true,
    })
    const fileHandle = await dbHandle.getFileHandle(`${model}.json`, {
      create: true,
    })
    const file = await fileHandle.getFile()
    const content = await file.text()
    return content ? JSON.parse(content) : []
  }

  private async write(model: string, data: any[]): Promise<void> {
    const dbHandle = await this.dirHandle.getDirectoryHandle('.rufasdb', {
      create: true,
    })
    const fileHandle = await dbHandle.getFileHandle(`${model}.json`, {
      create: true,
    })
    const writable = await fileHandle.createWritable()
    await writable.write(JSON.stringify(data, null, 2))
    await writable.close()
  }

  private isNumber(value: unknown): value is number {
    return typeof value === 'number'
  }

  private isArray(value: unknown): value is any[] {
    return Array.isArray(value)
  }

  private matchQuery(record: any, where: WhereCondition<any>): boolean {
    for (const [key, condition] of Object.entries(where)) {
      if (key === 'OR') {
        return (condition as WhereCondition<any>[]).some((orCondition) =>
          this.matchQuery(record, orCondition)
        )
      }

      if (key === 'AND') {
        return (condition as WhereCondition<any>[]).every((andCondition) =>
          this.matchQuery(record, andCondition)
        )
      }

      if (key === 'NOT') {
        return !this.matchQuery(record, condition)
      }

      const value = record[key]
      if (typeof condition !== 'object') {
        return value === condition
      }

      for (const [op, compareValue] of Object.entries(condition)) {
        switch (op) {
          case 'equals':
            if (value !== compareValue) return false
            break
          case 'gt':
            if (!this.isNumber(compareValue) || !(value > compareValue))
              return false
            break
          case 'gte':
            if (!this.isNumber(compareValue) || !(value >= compareValue))
              return false
            break
          case 'lt':
            if (!this.isNumber(compareValue) || !(value < compareValue))
              return false
            break
          case 'lte':
            if (!this.isNumber(compareValue) || !(value <= compareValue))
              return false
            break
          case 'contains':
            if (!String(value).includes(String(compareValue))) return false
            break
          case 'startsWith':
            if (!String(value).startsWith(String(compareValue))) return false
            break
          case 'endsWith':
            if (!String(value).endsWith(String(compareValue))) return false
            break
          case 'in':
            if (!this.isArray(compareValue) || !compareValue.includes(value))
              return false
            break
          case 'notIn':
            if (!this.isArray(compareValue) || compareValue.includes(value))
              return false
            break
        }
      }
    }
    return true
  }

  async findMany<T extends keyof Schema>(
    model: T,
    options?: QueryOptions<Schema[T]>
  ): Promise<Schema[T][]> {
    return this.queueOperation(async () => {
      this.data[model] = await this.read(model as string)
      let results = this.data[model]

      if (options?.where) {
        results = results.filter((record) =>
          this.matchQuery(record, options.where!)
        )
      }

      if (options?.orderBy) {
        const [sortField, direction] = Object.entries(options.orderBy)[0]
        results.sort((a, b) =>
          direction === 'asc'
            ? a[sortField] > b[sortField]
              ? 1
              : -1
            : a[sortField] < b[sortField]
            ? 1
            : -1
        )
      }

      if (options?.skip) results = results.slice(options.skip)
      if (options?.take) results = results.slice(0, options.take)

      return results
    })
  }

  async create<T extends keyof Schema>(
    model: T,
    data: Omit<Schema[T], 'id'>
  ): Promise<Schema[T]> {
    return this.queueOperation(async () => {
      this.data[model] = await this.read(model as string)

      const newRecord = {
        ...data,
        id: crypto.randomUUID(),
      }

      this.data[model].push(newRecord)
      await this.write(model as string, this.data[model])

      return newRecord as Schema[T]
    })
  }

  async update<T extends keyof Schema>(
    model: T,
    id: string,
    data: Partial<Schema[T]>
  ): Promise<Schema[T]> {
    return this.queueOperation(async () => {
      this.data[model] = await this.read(model as string)

      const index = this.data[model].findIndex((r: any) => r.id === id)
      if (index === -1) throw new Error('Record not found')

      const updated = {
        ...this.data[model][index],
        ...data,
      }

      this.data[model][index] = updated
      await this.write(model as string, this.data[model])

      return updated as Schema[T]
    })
  }

  async delete<T extends keyof Schema>(model: T, id: string): Promise<void> {
    return this.queueOperation(async () => {
      this.data[model] = await this.read(model as string)

      const index = this.data[model].findIndex((r: any) => r.id === id)
      if (index === -1) throw new Error('Record not found')

      this.data[model].splice(index, 1)
      await this.write(model as string, this.data[model])
    })
  }
}
</content>
</document>
<document>
<source>src/index.ts</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T09:44:39.765Z</last_modified>
  <file_type>ts</file_type>
</document_metadata>
<content>// src/index.ts
export * from './client'
export * from './types'
</content>
</document>
<document>
<source>src/types.ts</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T09:41:58.649Z</last_modified>
  <file_type>ts</file_type>
</document_metadata>
<content>// src/types.ts
export type Operators = {
  equals?: any
  gt?: number
  gte?: number
  lt?: number
  lte?: number
  contains?: string
  startsWith?: string
  endsWith?: string
  in?: any[]
  notIn?: any[]
}

export type WhereCondition<T> = {
  [K in keyof T]?: T[K] | Operators
} & {
  OR?: WhereCondition<T>[]
  AND?: WhereCondition<T>[]
  NOT?: WhereCondition<T>
}

export type QueryOptions<T> = {
  where?: WhereCondition<T>
  take?: number
  skip?: number
  orderBy?: { [K in keyof T]?: 'asc' | 'desc' }
}
</content>
</document>
<document>
<source>package.json</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T10:21:31.490Z</last_modified>
  <file_type>json</file_type>
</document_metadata>
<content>{
  "name": "rufasdb",
  "version": "0.0.1",
  "description": "Prisma-like flat-file database for browser",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "rufas": "./dist/cli/index.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc -w",
    "generate": "node dist/cli/index.js generate"
  },
  "files": [
    "dist",
    "README.md"
  ],
  "keywords": [
    "database",
    "filesystem",
    "browser",
    "orm"
  ],
  "author": "whaleen",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^20.17.10",
    "typescript": "^5.0.0"
  }
}
</content>
</document>
<document>
<source>README.md</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T10:52:02.840Z</last_modified>
  <file_type>md</file_type>
</document_metadata>
<content># Install

`npm install rufasdb@beta`

# Create schema

`touch schema.rufas`

# Generate types

`npx rufas generate`

# Use in code

`import { RufasDB } from 'rufasdb'`
</content>
</document>
<document>
<source>tsconfig.json</source>
<document_metadata>
  
  <tags>

  </tags>
  <last_modified>2024-12-31T10:02:48.150Z</last_modified>
  <file_type>json</file_type>
</document_metadata>
<content>{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "types": ["node"],
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "examples"]
}
</content>
</document>
</documents>
</rufas>